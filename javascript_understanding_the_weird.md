# Javascript Understanding the Weird

### Syntax Parsers
The first function of syntax analysis (parsing) is to verify whether the source program is syntactically well-formed (i.e., correct).  The parser obtains a string of tokens from the scanner (generated by a scanner definition file as shown above) and verifies that the string can be generated by the grammar for the source language.  (If not, the source program is not syntactically correct.)

The output from the parser is assumed to be a representation of the parse tree (example shown above) for the stream of tokens produced by the scanner.

There are many approaches to parsing, including both top-down and bottom-up approaches, as well as using leftmost or rightmost derivation.  The LR parsing method discussed uses a bottom-up approach to construct a rightmost derivation.

### Lexical Environment
Lexical Environment of a part of code signifies where it is written and what it is surrounded by.

### Execution Context
There are lots of lexical environments. Which one is currently running is managed via execution contexts.
It can contain things beyond what you've written in your code.

**It's important**

### Name / Value Pairs
There is a name, and it is assigned a value
eg
```Python
Address = '100 Main St.'
```

### Object:
Object is a collection of name value pairs.
Name can have other list of Name value pairs

## Global
There a global object in every lexical environment, `this` references to that global object.
Code not inside any function belongs to global.

```Javascript
var a = 5

function b() {

}

console.log(this)
```

a and b will be members of global object.
```Javascript
Window {window: Window, self: Window, document: document, name: "", location: Location, …}
EmberENV: {_DEBUG_RENDER_TREE: true}
GetParams: ƒ (t)
a: 5 <=
alert: ƒ alert()
atob: ƒ atob()
b: ƒ b() <=
blur: ƒ blur()
btoa: ƒ btoa()
caches: CacheStorage {}
cancelAnimationFrame: ƒ cancelAnimationFrame()
cancelIdleCallback: ƒ cancelIdleCallback()
captureEvents: ƒ captureEvents()
chrome: {loadTimes: ƒ, csi: ƒ}
clearInterval: ƒ clearInterval()
clearTimeout: ƒ clearTimeout()
clientInformation: Nav
```

Javascript functions can be called before defination
```Javascript
b()
function b(){
  console.log('Hello')
}
```
works..!
This phenonmon is called hoisting.

### Execution Context Phase I
### Allocation Phase
### Hoisting
Before javascript engine starts executing code line by line, it already allocated memory space
for variables and functions in your code.
When code is started to be executed line by line, it knows about the variables and functions.
During the allocation process, engine doesnot know what the ultimate value of variables is going to be.
So it uses a placeholder value `undefined` for the variable during allocation time.
- All variables in javascript are intially set to be `undefined`.

- `undefined` is a special value that javascript has in it to signify that variable value is not defined yet.

Having variable to be `undefined` means value is not declared for variable.
Reference error not defined means, variable or identifier itself (not it's value) is not declared/defined.

### Execution Context Phase 2: Running code
Sets variable values
and executes code

### Single Threaded
- One Command at a Time and in Order.

### Function Invocation and The Execution Stack
```Javascript
function b() {
}

function a() {
  b();
}

a();

```

- Whenever you invoke a function in js, a new execution context is created and on top of context wher  it is called from.

Execution Stack
--------------------------
| b() Exection context   |
--------------------------
-------------------------
| a() Exection context   |
--------------------------
--------------------------
| Global Exection context |
---------------------------

- When function finishes, it's execution context is popped out of context.

### Variable Environments
Where the variables live (scope)
Every execution context has it's own variable environment.
